{"version":3,"sources":["../js/camera.js"],"names":["Camera","window","plane","scale","HDPScale","edge_x","width","edge_y","height","offset","V2D","offsetX","offsetY","new_x","focus","x","new_y","y","regX","regY","rotation","ship","obj","shortestPossibleRadius","length","distanceBetweenObjectAndFocus","Physics","distance","position","radius","padding","v","not_visible","camera","is_visible","new_focus","whileCondition","timingFunction","BezierEasing","old_focus","startAngle","endAngle","Math","abs","clockwise","setAnimationTimeout","dt","elapsed","timeout","percentage","p1","p2","delta_v","sub","add","currentAngle","diff","checkCount","check","prop","setTimeout"],"mappings":"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","file":"camera.js","sourcesContent":["class Camera {\n\n  constructor(window, plane, scale, HDPScale) {\n    this.window = window; this.plane = plane; this.scale = scale; this.HDPScale = HDPScale;\n    this.edge_x = -this.plane.width + this.window.width;\n    this.edge_y = -this.plane.height + this.window.height;\n    this.offset = new V2D();\n  }\n\n  update() {\n    // const offsetX = this.window.width / 2,\n    //       offsetY = this.window.height / 2;\n    //\n    // let new_x = -this.focus.x + offsetX;\n    // let new_y = -this.focus.y + offsetY;\n    //\n    // if(new_x > 0) new_x = 0;\n    // if(new_y > 0) new_y = 0;\n    // if(new_x < this.edge_x) new_x = this.edge_x;\n    // if(new_y < this.edge_y) new_y = this.edge_y;\n    //\n    // this.plane.x = new_x;\n    // this.plane.y = new_y;\n\n\n    const offsetX = this.window.width  /  ( 1 / ( 1 / 2 )),\n          offsetY = this.window.height /  ( 1 / ( 5 / 8 ));\n\n    // let new_x = -this.focus.x + offsetX;\n    // let new_y = -this.focus.y + offsetY;\n\n    let new_x = this.focus.x;\n    let new_y = this.focus.y;\n\n    // if(new_x > 0) new_x = 0;\n    // if(new_y > 0) new_y = 0;\n    // if(new_x < this.edge_x) new_x = this.edge_x;\n    // if(new_y < this.edge_y) new_y = this.edge_y;\n\n    this.offset.x = this.plane.x = offsetX * this.HDPScale;\n    this.offset.y = this.plane.y = offsetY * this.HDPScale;\n\n    this.plane.regX = new_x;\n    this.plane.regY = new_y;\n\n    this.plane.rotation = -this.focus.ship.rotation - 90;\n  }\n\n  showing(obj) {\n    // box approach\n    // everything within the 4 corners of the view box were to be shown\n    //\n    // const r = obj.radius;\n    // return (\n    //   ((obj.position.x-r) + this.plane.x < this.width) &&\n    //   ((obj.position.x+r) + this.plane.x > 0) &&\n    //   ((obj.position.y-r) + this.plane.y < this.height) &&\n    //   ((obj.position.y+r) + this.plane.y > 0)\n    // )\n\n\n    // radius approach\n    // since box gets rotated.. everything within the longest distance is shown\n\n    const shortestPossibleRadius = this.offset.length / this.scale;\n\n    const distanceBetweenObjectAndFocus = Physics.distance(this.focus, obj.position);\n\n    return ( distanceBetweenObjectAndFocus - obj.radius ) < shortestPossibleRadius\n\n  }\n\n  closest_match(obj, padding = 10) {\n    let v = new V2D(),\n        not_visible = false;\n\n    v.x = obj.position.x + this.camera.plane.x;\n    v.y = obj.position.y + this.camera.plane.y;\n    if(v.x < padding) { v.x = padding; not_visible = true; }\n    if(v.x > this.window.width - padding) { v.x = this.window.width - padding; not_visible = true; }\n    if(v.y < padding) { v.y = padding; not_visible = true; }\n    if(v.y > this.window.height - padding) { v.y = this.window.height - padding; not_visible = true; }\n\n    return { is_visible: !not_visible, position: v }\n  }\n\n  /*\n   * this.animateFocus: eases the focus coordinate from one target to another while a condition is true after an amount\n   * of time.\n   */\n  animateFocus(new_focus, whileCondition) {\n    // log(this.focus); log(new_focus);\n    const timingFunction = BezierEasing(0.4, 0.0, 0.2, 1),\n          old_focus = this.focus;\n\n    let startAngle = old_focus.ship.rotation % 360;\n    let endAngle = new_focus.ship.rotation % 360;\n    if(Math.abs(endAngle - startAngle) > 180) {\n      if(startAngle < endAngle) {\n        startAngle += 360;\n      } else {\n        endAngle += 360;\n      }\n    }\n    const clockwise = endAngle - startAngle > 0; // (+ clockwise, - counterclockwise)\n\n    setAnimationTimeout((dt, elapsed, timeout)=>{\n      const percentage = elapsed / timeout;\n      const p1 = new V2D(old_focus.x, old_focus.y);\n      const p2 = new V2D(new_focus.x, new_focus.y);\n      const delta_v = p2.sub(p1);\n      delta_v.length = delta_v.length * timingFunction(percentage);\n      p1.add(delta_v);\n\n      startAngle = old_focus.ship.rotation % 360;\n      endAngle = new_focus.ship.rotation % 360;\n      let currentAngle = 0;\n      if(clockwise) {\n        if(endAngle < startAngle) endAngle += 360;\n        let diff = endAngle - startAngle;\n        currentAngle = startAngle + (diff * percentage);\n      } else {\n        if(endAngle > startAngle) endAngle -= 360;\n        let diff = startAngle - endAngle;\n        currentAngle = startAngle - (diff * percentage);\n      }\n\n      this.focus = {x:p1.x, y:p1.y, ship: {rotation: currentAngle}};\n    }, 1, ()=>{\n      this.focus = new_focus;\n      this.checkCount = 0;\n      check();\n    });\n\n    // from here stems the infamous camera glitch...\n    // (a continuous post check is required for slower machines that run at < 60 fps)\n    let [obj, prop] = whileCondition;\n    let check = () => {\n\n      if(obj[prop]) {\n\n        setTimeout(()=>{ check() }, 16)\n\n      } else {\n\n        if(!(this.checkCount++ > 60)){\n          setTimeout(()=>{ check() }, 16)\n        }\n\n        this.focus = old_focus;\n\n      }\n\n    };\n  }\n\n}\n\n"]}