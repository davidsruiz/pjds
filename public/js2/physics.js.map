{"version":3,"sources":["../js/physics.js"],"names":["Physics","p1","p2","Math","sqrt","sqr","x","y","a","b","distance","position","radius","fluid","stationary","force","vel","velocity","length","force_vector","copy","sub","add"],"mappings":";;;;;;IAAMA,O;;;;;;;6BAEYC,E,EAAIC,E,EAAI;AACtB,aAAOC,KAAKC,IAAL,CAAUD,KAAKE,GAAL,CAASH,GAAGI,CAAH,GAAOL,GAAGK,CAAnB,IAAwBH,KAAKE,GAAL,CAASH,GAAGK,CAAH,GAAON,GAAGM,CAAnB,CAAlC,CAAP;AACD;;;4BAEcC,C,EAAGC,C,EAAG;AACnB,aAAOT,QAAQU,QAAR,CAAiBF,EAAEG,QAAnB,EAA6BF,EAAEE,QAA/B,IAA2CH,EAAEI,MAAF,GAAWH,EAAEG,MAA/D;AACD;;AAED;;;;2BACcC,K,EAAOC,U,EAAYC,K,EAAO;AACtC,UAAIC,MAAMH,MAAMI,QAAN,CAAeC,MAAzB;;AACI;AACA;AACA;AACAC,qBAAeN,MAAMF,QAAN,CAAeS,IAAf,GAAsBC,GAAtB,CAA0BP,WAAWH,QAArC,CAJnB;AAKAQ,mBAAaD,MAAb,GAAsBH,SAAS,GAA/B,CANsC,CAMF;AACpC;AACAF,YAAMI,QAAN,CAAeK,GAAf,CAAmBH,YAAnB;AACD;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;4BAEeX,C,EAAGC,C,EAAG;AACnB,aAAO,CAACD,EAAEI,MAAF,GAAWH,EAAEG,MAAb,GAAsBZ,QAAQU,QAAR,CAAiBF,EAAEG,QAAnB,EAA6BF,EAAEE,QAA/B,CAAvB,KAAoEH,EAAEI,MAAF,GAAWH,EAAEG,MAAjF,CAAP;AACD","file":"physics.js","sourcesContent":["class Physics {\n\n  static distance(p1, p2) {\n    return Math.sqrt(Math.sqr(p2.x - p1.x) + Math.sqr(p2.y - p1.y))\n  }\n\n  static doTouch(a, b) {\n    return Physics.distance(a.position, b.position) < a.radius + b.radius\n  }\n\n  // circular bounce w/ one static\n  static bounce(fluid, stationary, force) {\n    let vel = fluid.velocity.length,\n        // absorbed = 0.8,\n        // distance = Physics.distance(fluid.position, stationary.position),\n        // collision_distance = fluid.radius + stationary.radius,\n        force_vector = fluid.position.copy().sub(stationary.position);\n    force_vector.length = force || 300; //px/s\n    // force_vector.length = vel * bounce_multiplier;\n    fluid.velocity.add(force_vector);\n  }\n\n  // static bounce_off_line(circle, line_P1, line_P2) {\n  //   let line = line_P2.sub_(line_P1);\n  //   let rejection = V2D.rejc(circle.position.sub_(line_P1), line);\n  //   if(true) {\n  //   // if(rejection.length < circle.radius) {\n  //     rejection.mul(-2).length = circle.velocity.length;\n  //     circle.velocity.set(rejection);\n  //   }\n  // }\n\n  static overlap(a, b) {\n    return (a.radius + b.radius - Physics.distance(a.position, b.position)) / (a.radius + b.radius)\n  }\n\n}\n"]}